#summary A guide for people who want to know more about the implementation.
#labels Phase-Implementation

= Introduction =

This document is intended to give a thorough view of the design and implementation of the GData Scala client library. If you want to know more about how this library works, or contribute to the project, this is the starting point. It assumes the reader is familiar with [http://scala-lang.org Scala], the [http://code.google.com/apis/gdata/index.html GData API protocol], [http://www.atomenabled.org/developers/syndication/atom-format-spec.php Atom] and the [http://ietfreport.isoc.org/idref/draft-ietf-atompub-protocol/ Atom Publishing Protocol].

_Note: The Scala client library needs a working [http://scala-lang.org Scala] installation newer than 2.7.0-final. That means a [http://www.scala-lang.org/downloads/distrib/files/nightly/ nightly build], until a bug fix release is issued to deal with [https://lampsvn.epfl.ch/trac/scala/ticket/632 this bug]._

= Setup =

This section describes the steps to take if you want to start developing the library. It describes how to checkout the sources, build and run the tests. Everything is straight forward, so most readers used to [http://scala-lang.org Scala] development can skip this section and come back if needed.

Before you start, make sure you have installed the following software:

 * An [http://subversion.tigris.org/ svn] client.
 * [http://ant.apache.org ant]
 * A [http://scala-lang.org Scala] distribution greater than 2.7.0.
 * [http://emma.sourceforge.net/ emma] for code coverage (optional).

== Setting up your working copy ==

Follow the instructions on the [http://code.google.com/p/gdata-scala-client/source/checkout project website] to checkout a working copy. Then `cd` into the directory and type
{{{
$ ant build
}}}
Make sure the environment variable `SCALA_HOME` points to your Scala installation.

To build and run the tests, type
{{{
$ ant test
}}}

The build process can be configured by setting the appropriate values in `build.properties`. If you have installed [http://emma.sourceforge.net/ emma], make sure you update the properties file to point to its installation directory:
{{{
emma.dir=/usr/local/soft/emma-2.0.5312/lib
}}}

Now you can get an html report of test coverage:
{{{
$ ant coverage
}}}

= Library Overview =

The library is centered around serializing and deserializing XML. The design goals are:
  * favor composition over inheritance.
  * describe the XML structure in a natural way.
  * most elements can be extended with new elements/attributes. Such extensions should require code proportional to how much is added (extensibility).
  * the library should deal with user defined types without losing that information (type-safety).

The answer is an approach similar to [http://www.cs.kuleuven.be/publicaties/rapporten/cw/CW491.pdf combinator parsing] for handling XML serialization. More about that in the following sections.

== Conventions ==

The library goes to great lengths to provide a type-safe layer on top of the underlying XML protocol. Whenever possible, Scala data types are used to represent the underlying data. Here is a high level view of the conventions followed throughout the library:
 * whenever a piece of data is optional, it is represented as an `Option[T]`. *null* values should never be valid values.
 * whenever a default value is specified for an element or attribute, such data is represented as a value of the right type, and the default value is filled in when parsing.
 * all data is mutable. This is in order to support update (although some services are read-only).
 * serialization code is separated from data representation. Picklers (the name for serialization code) are usually found as values in the companion object of data classes.
 * errors in the HTTP transport layer are signaled as exceptions.
 * convenience methods and constructors are provided for the most common cases. For instance, an `EventEntry` has a constructor taking a title and a description as plain strings (although they could be `html` or `xhtml`) and two `DateTime` objects (although an event might have only one or none).
 * names in data classes closely follow the XML data they model. If an [http://code.google.com/apis/gdata/elements.html#gdEventKind event entry] has an element called `eventStatus`, the `EventEntry` class will have a field named the same. This makes it easy to use existing Google documentation.

== Organization ==

Along with the core classes for XML serialization (called _picklers_), there are classes that model the various data used by the GData protocol (like feeds, contacts, calendar entries, etc) and HTTP connection classes. The library is split in packages along the following lines:
  * `com.google.xml.combinators` The XML serialization core
  * `com.google.gdata.data` GData common classes, including the [http://atomenabled.org/developers/syndication/atom-format-spec.php Atom protocol] classes.
    * `kinds` Google [http://code.google.com/apis/gdata/elements.html kinds] classes (common data classes used by several Google services).
    * `media` [http://search.yahoo.com/mrss Media Rss] classes (used by the !YouTube service).
    * `util` various common classes like `DateTime` or `NormalPlayTime`
  * `com.google.gdata.client` GData HTTP connection and authentication handling.
  * `com.google.gdata.<servicename>` specific data classes and services for each implemented service, like Calendar or !YouTube.

= XML Pickling Combinators =



= Atom data classes =

= Feeds and Entries =

= Http and GData requests =


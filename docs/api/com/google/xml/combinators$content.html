<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
        <head><title>All classes and objects in com.google.xml.combinators</title>
        <meta http-equiv="content-type" content="text/html; charset=UTF8"></meta><meta content="scaladoc (version 2.7.1.RC1)" name="generator"></meta><link href="../../../style.css" type="text/css" rel="stylesheet"></link><script type="text/javascript" src="../../../script.js"></script>
        </head>
        <body onload="init()"><div class="page-title"><div>GData Scala Client</div></div><p><div>This document is the API specification for GData Scala Client Library Documentation</div></p><table summary="" cellpadding="3" class="member">
        <tr><td class="title" colspan="2">Class Summary</td></tr>
        <tr>
      <td class="modifiers" valign="top"> 
        <code> trait</code>
      </td>
      <td class="signature">
        <em><a href="../../../com/google/xml/combinators/HasStore.html" target="_self">HasStore</a></em>
        <code> extends </code><a href="http://www.scala-lang.org/docu/files/api/scala/AnyRef.html" target="_self">AnyRef</a>
        
        <div>A trait for extensible data. Unknown elements will be collected in 'store'.
 
 This can be used for 'after the fact' extension of picklers. A user-defined 
 type that mixes in HasStore must also use the 'extensible' combinator to 
 collect remaining input. An extension can then be be applied to the collected
 store: <code>extend(Person.pickler, extraElements)</code></div>
      </td>
    </tr>
<tr>
      <td class="modifiers" valign="top"> 
        <code> class</code>
      </td>
      <td class="signature">
        <em><a href="../../../com/google/xml/combinators/LinearStore.html" target="_self">LinearStore</a></em>
        (<em>ats</em> : <a href="" target="contentFrame" class="scala/xml/MetaData">scala.xml.MetaData</a>, <em>nods</em> : <a href="" target="contentFrame" class="scala/List">scala.List</a>[<a href="" target="contentFrame" class="scala/xml/Node">scala.xml.Node</a>], <em>bindings</em> : <a href="" target="contentFrame" class="scala/xml/NamespaceBinding">scala.xml.NamespaceBinding</a>)<code> extends </code><a href="../../../com/google/xml/combinators/XmlInputStore.html" target="_self">XmlInputStore</a>
        
        <div>This class encapsulate the state carried around
 when pickling or unpickling XML. This is an immutable data structure.
 Speaking from the point of view of unpickling, the store consists of a
 set of attributes not yet consumed, a set of nodes not yet consumed and
 a set of namespace bindings encountered so far.</div>
      </td>
    </tr>
<tr>
      <td class="modifiers" valign="top"> 
        <code>case class</code>
      </td>
      <td class="signature">
        <em><a href="../../../com/google/xml/combinators/MalformedXmlStore.html" target="_self">MalformedXmlStore</a></em>
        (<code>val </code><em>msg</em> : <a href="" target="contentFrame" class="java/lang/String">java.lang.String</a>, <code>val </code><em>state</em> : <a href="../../../com/google/xml/combinators/XmlOutputStore.html" target="_self">XmlOutputStore</a>)<code> extends </code><a href="" target="contentFrame" class="java/lang/RuntimeException">java.lang.RuntimeException</a><code> with </code><a href="" target="contentFrame" class="scala/Product">scala.Product</a>
        
        <div>An exception thrown when the XML output store is inconsistent.</div>
      </td>
    </tr>
<tr>
      <td class="modifiers" valign="top"> 
        <code> class</code>
      </td>
      <td class="signature">
        <em><a href="../../../com/google/xml/combinators/PlainOutputStore.html" target="_self">PlainOutputStore</a></em>
        (<code>val </code><em>attrs</em> : <a href="" target="contentFrame" class="scala/xml/MetaData">scala.xml.MetaData</a>, <em>nods</em> : <a href="" target="contentFrame" class="scala/Seq">scala.Seq</a>[<a href="" target="contentFrame" class="scala/xml/Node">scala.xml.Node</a>], <code>val </code><em>ns</em> : <a href="" target="contentFrame" class="scala/xml/NamespaceBinding">scala.xml.NamespaceBinding</a>)<code> extends </code><a href="../../../com/google/xml/combinators/XmlOutputStore.html" target="_self">XmlOutputStore</a>
        
        <div>A PlainOutputStore implements XmlOutputStore with reasonable efficiency. It
 is a mutable representation.</div>
      </td>
    </tr>
<tr>
      <td class="modifiers" valign="top"> 
        <code> class</code>
      </td>
      <td class="signature">
        <em><a href="../../../com/google/xml/combinators/RandomAccessStore.html" target="_self">RandomAccessStore</a></em>
        (<em>myAttrs</em> : <a href="" target="contentFrame" class="scala/xml/MetaData">scala.xml.MetaData</a>, <em>myNodes</em> : <a href="" target="contentFrame" class="scala/Seq">scala.Seq</a>[<a href="" target="contentFrame" class="scala/xml/Node">scala.xml.Node</a>], <em>myNs</em> : <a href="" target="contentFrame" class="scala/xml/NamespaceBinding">scala.xml.NamespaceBinding</a>, <em>level</em> : <a href="http://www.scala-lang.org/docu/files/api/scala/Int.html" target="_self">Int</a>)<code> extends </code><a href="../../../com/google/xml/combinators/LinearStore.html" target="_self">LinearStore</a>
        
        <div>This class matches elements at any position in the sequence of nodes. This allows
 unpicklers to accept any permutation of a defined sequence. 
 
 For efficiency reasons, this class uses a mutable representation for elements. When
 an instance is created, this class creates a map from element labels (regardless of
 namespace) to XML elements. This allows access in constant time implementation of
 the 'acceptElem' method.</div>
      </td>
    </tr>
<tr>
      <td class="modifiers" valign="top"> 
        <code> trait</code>
      </td>
      <td class="signature">
        <em><a href="../../../com/google/xml/combinators/TupleToPairFunctions.html" target="_self">TupleToPairFunctions</a></em>
        <code> extends </code><a href="http://www.scala-lang.org/docu/files/api/scala/AnyRef.html" target="_self">AnyRef</a>
        
        <div>Mix in this trait to get implicit conversions between functions of arity 2-7 and 
 functions that take nested instances of '~' pairs.
 
 This is particularly useful when pickling case classes. Complier generated functions for
 apply and unapply are then implicitly converted to functions that take '~' instances.
 
 Example:
 <code>
 case class Foo(x: Int, y: String)
 
 wrap (elem("x", intVal) ~ elem("y", text)) Foo.apply Foo.unapply</div>
      </td>
    </tr>
<tr>
      <td class="modifiers" valign="top"> 
        <code> trait</code>
      </td>
      <td class="signature">
        <em><a href="../../../com/google/xml/combinators/XmlInputStore.html" target="_self">XmlInputStore</a></em>
        <code> extends </code><a href="../../../com/google/xml/combinators/XmlStore.html" target="_self">XmlStore</a><code> with </code><a href="http://www.scala-lang.org/docu/files/api/scala/AnyRef.html" target="_self">AnyRef</a>
        
        <div>This class represents the input of picklers. It keeps around XML attributes,
 nodes and current namespace bindings. There are two modes in which input stores
 operate: linear and random access. A linear store will return elements in the 
 order in which they are defined in the XML document. A random access store will
 look the element up anywhere in the 'nodes' collection. Switching between the 
 two modes is done by calling 'randomAccessMode' and 'linearAccessMode'. The modes
 nest (randomAccessMode and linearAccessMode calls have to match). 
 
 All 'accept' methods return an instance of XmlInputStore which is the input after
 the accepted element was consumed. Implementers may choose whether to implement 
 it using mutable state (and return 'this') or use an immutable representation.</div>
      </td>
    </tr>
<tr>
      <td class="modifiers" valign="top"> 
        <code> trait</code>
      </td>
      <td class="signature">
        <em><a href="../../../com/google/xml/combinators/XmlOutputStore.html" target="_self">XmlOutputStore</a></em>
        <code> extends </code><a href="../../../com/google/xml/combinators/XmlStore.html" target="_self">XmlStore</a><code> with </code><a href="http://www.scala-lang.org/docu/files/api/scala/AnyRef.html" target="_self">AnyRef</a>
        
        <div>An XML store used during pickling. It provides methods for adding
 XML elements, attributes and namespaces. Implementers decide on the
 actual strategy for looking up elements based on name (linear or 
 random access).</div>
      </td>
    </tr>
<tr>
      <td class="modifiers" valign="top"> 
        <code> trait</code>
      </td>
      <td class="signature">
        <em><a href="../../../com/google/xml/combinators/XmlStore.html" target="_self">XmlStore</a></em>
        <code> extends </code><a href="http://www.scala-lang.org/docu/files/api/scala/AnyRef.html" target="_self">AnyRef</a>
        
        <div>An interface for XML stores. It keeps around a collection of attributes, elements and 
 namespace bindings.</div>
      </td>
    </tr>
<tr>
      <td class="modifiers" valign="top"> 
        <code>case final class</code>
      </td>
      <td class="signature">
        <em><a href="../../../com/google/xml/combinators/$tilde.html" target="_self">~</a></em>
        [+<em>A</em>, +<em>B</em>](<code>val </code><em>_1</em> : <a href="../../../com/google/xml/combinators/$tilde.html#A" target="_self">A</a>, <code>val </code><em>_2</em> : <a href="../../../com/google/xml/combinators/$tilde.html#B" target="_self">B</a>)<code> extends </code><a href="" target="contentFrame" class="scala/Product">scala.Product</a>
        
        <div>Convenience class to hold two values (it has lighter syntax than pairs).</div>
      </td>
    </tr>        
        </table>
<table summary="" cellpadding="3" class="member">
        <tr><td class="title" colspan="2">Object Summary</td></tr>
        <tr>
      <td class="modifiers" valign="top"> 
        <code> object</code>
      </td>
      <td class="signature">
        <em><a href="../../../com/google/xml/combinators/LinearStore$object.html" target="_self">LinearStore</a></em>
        <code> extends </code><a href="http://www.scala-lang.org/docu/files/api/scala/AnyRef.html" target="_self">AnyRef</a>
        
        <div>Convenience object for creating LinearStores</div>
      </td>
    </tr>
<tr>
      <td class="modifiers" valign="top"> 
        <code> object</code>
      </td>
      <td class="signature">
        <em><a href="../../../com/google/xml/combinators/MalformedXmlStore$object.html" target="_self">MalformedXmlStore</a></em>
        <code> extends </code>(<a href="" target="contentFrame" class="java/lang/String">java.lang.String</a>, <a href="../../../com/google/xml/combinators/XmlOutputStore.html" target="_self">XmlOutputStore</a>) =&gt; <a href="../../../com/google/xml/combinators/MalformedXmlStore.html" target="_self">MalformedXmlStore</a>
        
        
      </td>
    </tr>
<tr>
      <td class="modifiers" valign="top"> 
        <code> object</code>
      </td>
      <td class="signature">
        <em><a href="../../../com/google/xml/combinators/Picklers$object.html" target="_self">Picklers</a></em>
        <code> extends </code><a href="../../../com/google/xml/combinators/TupleToPairFunctions.html" target="_self">TupleToPairFunctions</a>
        
        <div>A class for XML Pickling combinators.</div>
      </td>
    </tr>
<tr>
      <td class="modifiers" valign="top"> 
        <code> object</code>
      </td>
      <td class="signature">
        <em><a href="../../../com/google/xml/combinators/PlainOutputStore$object.html" target="_self">PlainOutputStore</a></em>
        <code> extends </code><a href="http://www.scala-lang.org/docu/files/api/scala/AnyRef.html" target="_self">AnyRef</a>
        
        <div>Factory for output stores.</div>
      </td>
    </tr>
<tr>
      <td class="modifiers" valign="top"> 
        <code> object</code>
      </td>
      <td class="signature">
        <em><a href="../../../com/google/xml/combinators/$tilde$object.html" target="_self">~</a></em>
        <code> extends </code><a href="http://www.scala-lang.org/docu/files/api/scala/AnyRef.html" target="_self">AnyRef</a>
        
        
      </td>
    </tr>        
        </table></body>
      </html>